<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Hiệu ứng Lỗ Đen Phong Cách Anime (Fiery Style)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* Thiết lập tất cả canvas đều nằm chồng lên nhau */
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        
        /* Canvas tính toán, không cần hiển thị */
        #swirlComputeCanvas {
            display: none; 
        }

/* --- SẮP XẾP LỚP THEO z-index (ĐÃ CẬP NHẬT) --- */
#backgroundCanvas   { z-index: 1; }
#pathCanvas         { z-index: 2; }
#swirlDisplayCanvas { z-index: 3; } /* Lớp nền màu cam */
#centerGlowCanvas   { z-index: 4; } /* Quầng sáng mềm bên trong */
#particleCanvas     { z-index: 5; } /* Các hạt lửa */
#coreCanvas         { z-index: 6; } /* Lõi đen với viền nóng chảy */
#glowCanvas         { z-index: 7; } /* Vòng sáng nóng nhất (vàng trắng) */
#GlowCircle2        { z-index: 8; filter:blur(2px);} /* Vòng sáng trắng rung động (MỚI) */
#CloudRing          { z-index: 9; } /* Vòng mây lửa */
#outerGlowCanvas    { z-index: 10;} /* Quầng sáng cam bên ngoài */

        /* CÁCH NÀY SẼ CHO KẾT QUẢ SAI */
#backgroundCanvas,
#pathCanvas,
#swirlDisplayCanvas,
#centerGlowCanvas,
#particleCanvas,
#coreCanvas,
#glowCanvas,
#CloudRing,
#outerGlowCanvas {
    filter: hue-rotate(160deg) saturate(150%);
}

/* Lớp particle vừa bị xoay màu, vừa bị blur */
#particleCanvas {
    filter: hue-rotate(120deg) saturate(50%) blur(0px);
}
    </style>
</head>

<body>
    <!-- Canvas để tính toán, sẽ được ẩn đi -->
    <canvas id="swirlComputeCanvas"></canvas>

    <!-- Các canvas hiển thị, được sắp xếp bằng z-index -->
    <canvas id="backgroundCanvas"></canvas>
    <canvas id="pathCanvas"></canvas>
    <canvas id="particleCanvas"></canvas>
    <canvas id="swirlDisplayCanvas"></canvas>
    <canvas id="centerGlowCanvas"></canvas> 
    <canvas id="coreCanvas"></canvas>
    <canvas id="glowCanvas"></canvas>
    <canvas id="CloudRing"></canvas>
    <canvas id="outerGlowCanvas"></canvas>
    <canvas id="GlowCircle2"></canvas>


<!-- ========================================================== -->
<!-- == SCRIPT 1: HIỆU ỨNG LỖ ĐEN, QUẦNG SÁNG VÀ HẠT (ĐÃ CHỈNH SỬA) ======== -->
<!-- ========================================================== -->

<script>
    // ---- CÀI ĐẶT VÀ BIẾN TOÀN CỤC ----
    const backgroundCanvas = document.getElementById('backgroundCanvas');
    const bgCtx = backgroundCanvas.getContext('2d');
    const pathCanvas = document.getElementById('pathCanvas'); 
    const pathCtx = pathCanvas.getContext('2d');
    const particleCanvas = document.getElementById('particleCanvas'); 
    const pCtx = particleCanvas.getContext('2d');
    
    const swirlDisplayCanvas = document.getElementById('swirlDisplayCanvas');
    const swirlDisplayCtx = swirlDisplayCanvas.getContext('2d');
    const coreCanvas = document.getElementById('coreCanvas');
    const coreCtx = coreCanvas.getContext('2d');
    const glowCanvas = document.getElementById('glowCanvas');
    const glowCtx = glowCanvas.getContext('2d');
    const outerGlowCanvas = document.getElementById('outerGlowCanvas');
    const outerGlowCtx = outerGlowCanvas.getContext('2d');
    const centerGlowCanvas = document.getElementById('centerGlowCanvas');
    const centerGlowCtx = centerGlowCanvas.getContext('2d');
    const glowCircle2Canvas = document.getElementById('GlowCircle2'); // Đã có sẵn
    const glowCircle2Ctx = glowCircle2Canvas.getContext('2d'); // Đã có sẵn

    const allCanvases = [
        backgroundCanvas, pathCanvas, particleCanvas, swirlDisplayCanvas, 
        centerGlowCanvas, coreCanvas, glowCanvas, 
        document.getElementById('CloudRing'), outerGlowCanvas,
        glowCircle2Canvas // <-- THÊM MỚI: Thêm glowCircle2Canvas vào danh sách để resize
    ];

    let particles = [];
    const PARTICLE_COUNT = 1000; 
    const COLORS = ['#FFFFE0', '#FFD700', '#FFA500', '#FF4500', '#FF6347'];
    const WEAK_DRAG = 0.999; 
    const STRONG_DRAG = 0.98; 
    const HISTORY_LENGTH = 1; 
    const TRAIL_BASE_OPACITY = 0.6; 
    const TRAIL_BASE_WIDTH_FACTOR = 1.2; 
    const blackHole = { x: 0, y: 0, radius: 180, mass: 10000 };
    const CRITICAL_DISTANCE = blackHole.radius * 2.5; 
    let CONTAINMENT_RADIUS = 0; 
    
    function setAllCanvasSize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        allCanvases.forEach(canvas => {
            canvas.width = width;
            canvas.height = height;
        });
        
        CONTAINMENT_RADIUS = (Math.min(width, height) / 2) * 1.1;
        blackHole.x = width / 2;
        blackHole.y = height / 2;
        
        drawStaticBackground();
        
        if (particles.length > 0) {
            particles.forEach(p => p.reset());
        } else {
             initParticles();
        }
    }
    
    function drawStaticBackground() {
         bgCtx.clearRect(0, 0, backgroundCanvas.width, backgroundCanvas.height);
         for (let i = 0; i < 800; i++) { 
            const x = Math.random() * backgroundCanvas.width;
            const y = Math.random() * backgroundCanvas.height;
            const size = Math.random() * 2;
            const opacity = Math.random() * 0.4 + 0.1; 
            bgCtx.fillStyle = `rgba(255, 239, 213, ${opacity})`;
            bgCtx.fillRect(x, y, size, size); 
        }
    }
    
    function drawSwirl() {
        const swirlComputeCanvas = document.getElementById('swirlComputeCanvas');
        if (swirlComputeCanvas) {
            swirlDisplayCtx.clearRect(0, 0, swirlDisplayCanvas.width, swirlDisplayCanvas.height);
            const scaleFactor = 6; 
            const newWidth = swirlComputeCanvas.width * scaleFactor;
            const newHeight = swirlComputeCanvas.height * scaleFactor;
            const x = (swirlDisplayCanvas.width - newWidth) / 2;
            const y = (swirlDisplayCanvas.height - newHeight) / 2;
            swirlDisplayCtx.globalAlpha = 0.85;
            swirlDisplayCtx.drawImage(swirlComputeCanvas, x, y, newWidth, newHeight); 
            swirlDisplayCtx.globalAlpha = 1.0; 
        }
    }
    
    function drawCenterGlow() {
        centerGlowCtx.clearRect(0, 0, centerGlowCanvas.width, centerGlowCanvas.height);
        const gradient = centerGlowCtx.createRadialGradient(
            blackHole.x, blackHole.y, 0,
            blackHole.x, blackHole.y, blackHole.radius * 5 
        );
        gradient.addColorStop(0, 'rgba(255, 255, 224, 0.9)');
        gradient.addColorStop(0.2, 'rgba(255, 200, 0, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 140, 0, 0.6)');
        gradient.addColorStop(1, 'rgba(205, 92, 92, 0)');

        centerGlowCtx.fillStyle = gradient;
        centerGlowCtx.fillRect(0, 0, centerGlowCanvas.width, centerGlowCanvas.height);
    }

 // Hàm mới để vẽ vòng sáng rung động, xoay tròn và bất ổn
function drawGlowCircle2(time) {
    glowCircle2Ctx.clearRect(0, 0, glowCircle2Canvas.width, glowCircle2Canvas.height);

    // --- 1. HIỆU ỨNG RUNG ĐỘNG (Pulsate) ---
    // Tạo hiệu ứng co giãn, phồng lên xẹp xuống nhịp nhàng
    const pulse = (Math.sin(time * 0.00001) + 10) / 2; // Dao động mượt từ 0 đến 1. chỉnh cao quá sẽ thành thiên hà

    // --- 2. HIỆU ỨNG XOAY (Rotate) ---
    // Tạo một góc quay liên tục thay đổi theo thời gian
    const rotationSpeed = -0.002; // Tốc độ và chiều quay (âm là quay ngược chiều kim đồng hồ)
    const baseRotation = time * rotationSpeed;

    // --- 3. HIỆU ỨNG RUNG LẮC (Jitter) ---
    // Tạo ra sự rung lắc ngẫu nhiên, không ổn định cho vòng tròn
    const jitterAmount = 1.5; // Độ rung lắc tối đa (tính bằng pixel)
    const radiusJitter = (Math.random() - 4) * jitterAmount; // Thay đổi bán kính ngẫu nhiên

    // --- THIẾT LẬP THUỘC TÍNH VÒNG SÁNG ---
    const finalRadius = blackHole.radius + 10 + radiusJitter; // Bán kính cuối cùng có cả rung lắc
    const color = '#FFFFFF';
    
    // Độ dày và độ mờ của glow sẽ thay đổi theo nhịp "pulse"
    const lineWidth = 10 + pulse * 10;     // Rung động từ 3px đến 8px
    const glowBlur = 10 + pulse * 10;    // Hiệu ứng BLUR: Rung động từ 15px đến 35px
    const globalAlpha = 0.8 + pulse * 0.2; // Độ trong suốt cũng rung động

    // --- BẮT ĐẦU VẼ ---
    glowCircle2Ctx.save();
    glowCircle2Ctx.lineCap = 'round'; // Làm cho đầu các đoạn sáng mềm mại hơn

    // Thiết lập hiệu ứng GLOW và BLUR
    glowCircle2Ctx.strokeStyle = color;
    glowCircle2Ctx.lineWidth = lineWidth;
    glowCircle2Ctx.shadowColor = color; // Màu của quầng sáng (glow)
    glowCircle2Ctx.shadowBlur = glowBlur;   // Độ mờ của quầng sáng (blur)
    glowCircle2Ctx.globalAlpha = globalAlpha;

    // --- VẼ CÁC ĐOẠN SÁNG XOAY TRÒN ---
    const numSegments = 10; // Số lượng đoạn sáng
    const segmentLength = Math.PI / 1.5; // Độ dài của mỗi đoạn sáng (tính bằng radian)

    // Vòng lặp để vẽ từng đoạn sáng
    for (let i = 0; i < numSegments; i++) {
        // Mỗi segment bắt đầu một path mới để chúng không nối liền với nhau
        glowCircle2Ctx.beginPath(); 
        
        // Tính toán góc bắt đầu và kết thúc cho mỗi đoạn, cộng với góc quay `baseRotation`
        const startAngle = baseRotation + (i * (Math.PI * 2) / numSegments);
        const endAngle = startAngle + segmentLength;

        // Vẽ một cung tròn (đoạn sáng)
        glowCircle2Ctx.arc(blackHole.x, blackHole.y, finalRadius, startAngle, endAngle);
        
        // Thực hiện vẽ đoạn sáng này ra canvas
        glowCircle2Ctx.stroke();
    }
    
    glowCircle2Ctx.restore(); // Phục hồi trạng thái context
}


    // CẬP NHẬT: Lõi đen có hiệu ứng "nóng chảy"
    function drawBlackHoleCore() {
        coreCtx.clearRect(0, 0, coreCanvas.width, coreCanvas.height);
        // Tạo gradient cho lõi đen để có cảm giác nóng ở rìa
        const gradient = coreCtx.createRadialGradient(
            blackHole.x, blackHole.y, blackHole.radius * 0.9,
            blackHole.x, blackHole.y, blackHole.radius
        );
        gradient.addColorStop(0, '#000000'); // Phần lớn vẫn là màu đen
        gradient.addColorStop(0.8, '#110500'); // Chuyển dần sang đen-đỏ
        gradient.addColorStop(1, '#FF4500'); // Viền ngoài màu cam-đỏ rực
        
        coreCtx.beginPath();
        coreCtx.arc(blackHole.x, blackHole.y, blackHole.radius, 0, Math.PI * 2);
        coreCtx.fillStyle = gradient; 
        coreCtx.fill();
    }
    

    function drawGlowRing() {
        glowCtx.clearRect(0, 0, glowCanvas.width, glowCanvas.height);
        const GLOW_COLOR = 'rgba(255, 255, 250, 1)';
        const GLOW_WIDTH = 200;   
        const GLOW_BLUR = 500;   
        const glowRadius = blackHole.radius;
        const glowGradient = glowCtx.createRadialGradient(
            blackHole.x, blackHole.y, glowRadius - (GLOW_WIDTH / 2),
            blackHole.x, blackHole.y, glowRadius + GLOW_BLUR
        );
        
        glowGradient.addColorStop(0, 'rgba(0,0,0,0)');
        glowGradient.addColorStop(0.3, 'rgba(0,0,0,0)');
        glowGradient.addColorStop(0.5, GLOW_COLOR);
        glowGradient.addColorStop(1, 'rgba(255, 200, 0, 0)');

        glowCtx.fillStyle = glowGradient;
        glowCtx.filter = 'blur(1px)'; // 2. Áp dụng hiệu ứng blur
        glowCtx.beginPath();
        glowCtx.arc(blackHole.x, blackHole.y, glowRadius + GLOW_BLUR, 0, Math.PI * 2);
        glowCtx.fill();
    }
    
// ==========================================================
// THAY THẾ HÀM CŨ BẰNG HÀM NÀY
// ==========================================================

function drawOuterGlowRing() {
    outerGlowCtx.clearRect(0, 0, outerGlowCanvas.width, outerGlowCanvas.height);

    // BỌC TOÀN BỘ CODE CŨ TRONG CẶP LỆNH NÀY
    // ----------------------------------------------------
    outerGlowCtx.save(); // 1. Lưu trạng thái context

    outerGlowCtx.filter = 'blur(5px)'; // 2. Áp dụng hiệu ứng blur

    // === TOÀN BỘ CODE GỐC CỦA BẠN (giữ nguyên) ===
    const GLOW_COLOR = 'rgba(255, 255, 255, 1)'; // Sửa giá trị RGB không hợp lệ thành màu trắng
    const GLOW_WIDTH = 200;
    const GLOW_BLUR = 500;
    const glowRadius = blackHole.radius * 4;

    const glowGradient = outerGlowCtx.createRadialGradient(
        blackHole.x, blackHole.y, glowRadius - (GLOW_WIDTH / 1),
        blackHole.x, blackHole.y, glowRadius + GLOW_BLUR
    );

    glowGradient.addColorStop(0, 'rgba(0,0,0,0)');
    glowGradient.addColorStop(0.1, 'rgba(0,0,0,0)');
    glowGradient.addColorStop(0.65, GLOW_COLOR);
    glowGradient.addColorStop(1, 'rgba(0,0,0,0)');

    outerGlowCtx.fillStyle = glowGradient;
    outerGlowCtx.beginPath();
    outerGlowCtx.arc(blackHole.x, blackHole.y, glowRadius + GLOW_BLUR, 0, Math.PI * 2);
    outerGlowCtx.fill();
    // === KẾT THÚC CODE GỐC ===

    outerGlowCtx.restore(); // 3. Phục hồi trạng thái context (xóa bộ lọc blur)
    // ----------------------------------------------------
}    
// ==========================================================
// THAY THẾ TOÀN BỘ CLASS PARTICLE CŨ BẰNG CLASS NÀY (PHIÊN BẢN NÂNG CAO)
// ==========================================================

class Particle {
    constructor() {
        this.history = [];
        this.reset();
    }

    reset() {
        this.history = [];
        this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * (CONTAINMENT_RADIUS) + CRITICAL_DISTANCE;
        this.x = blackHole.x + Math.cos(angle) * distance;
        this.y = blackHole.y + Math.sin(angle) * distance;
        
        this.radius = Math.random() * 4 + 1.2; // Tăng nhẹ bán kính tối thiểu

        // THÊM MỚI: Biến để tạo hiệu ứng lấp lánh (Twinkle)
        this.twinkleFactor = Math.random() * 0.1 + 0.5; // Dao động từ 0.7 đến 1.2
        this.twinkleSpeed = (Math.random() - 0.5) * 0.1;

        const dx = blackHole.x - this.x;
        const dy = blackHole.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist === 0) {
            this.reset();
            return;
        }
        const orbitalVelocity = Math.sqrt(blackHole.mass / dist);
        const speedFactor = Math.random() * 0.5 + 0.6;
        let tangentX = -dy / dist;
        let tangentY = dx / dist;
        this.vx = tangentX * orbitalVelocity * speedFactor;
        this.vy = tangentY * orbitalVelocity * speedFactor;
    }

    // --- HÀM VẼ PARTICLE ĐƯỢC CẢI TIẾN LỚN ---
    drawParticle() {
        const currentRadius = this.radius * this.twinkleFactor;

        // --- LỚP 1: Vẽ quầng sáng RỘNG và MỀM bên ngoài nhất ---
        // Sử dụng gradient để tạo ra quầng sáng lan tỏa rộng, mô phỏng ánh sáng khuếch tán
        const outerGlowRadius = currentRadius * 7;
        const glowGradient = pCtx.createRadialGradient(
            this.x, this.y, 0,
            this.x, this.y, outerGlowRadius
        );
        // Bắt đầu với màu của ngôi sao nhưng rất mờ, và mờ dần ra trong suốt
        glowGradient.addColorStop(0, this.color + '44'); // Thêm '44' để chỉ định alpha (độ trong suốt)
        glowGradient.addColorStop(0, this.color + '00');

        pCtx.fillStyle = glowGradient;
        pCtx.beginPath();
        pCtx.arc(this.x, this.y, outerGlowRadius, 0, Math.PI * 2);
        pCtx.fill();

        // --- LỚP 2: Vẽ thân ngôi sao với quầng sáng gần ---
        // Lớp này tạo ra vùng sáng chính, đậm đặc hơn
        pCtx.shadowColor = this.color;
        pCtx.shadowBlur = 5;
        pCtx.fillStyle = this.color;
        
        pCtx.beginPath();
        pCtx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
        pCtx.fill();
        
        // --- LỚP 3: Vẽ lõi TRẮNG RỰC ở trung tâm ---
        // Lõi trắng tinh, sắc nét, tạo cảm giác nhiệt độ cực cao
        pCtx.shadowBlur = 0; // Tắt shadow để lõi sắc nét
        pCtx.fillStyle = '#FFFFFF';
        pCtx.beginPath();
        const coreRadius = Math.min(currentRadius * 0.5, 2.5); 
        pCtx.arc(this.x, this.y, coreRadius, 0, Math.PI * 2);
        pCtx.fill();

        // --- LỚP 4: Vẽ tia sáng (Spikes) cho các ngôi sao lớn ---
        if (this.radius > 1.5) { // Giảm ngưỡng để nhiều sao có tia hơn
            this.drawSpikes(currentRadius);
        }
    }

    // --- HÀM VẼ TIA SÁNG ĐƯỢC NÂNG CẤP VỚI GRADIENT ---
    drawSpikes(currentRadius) {
        const spikeLength = currentRadius * 4;
        const spikeOpacity = Math.min((this.radius - 2.5) / 2, 0.7) * this.twinkleFactor;
        
        pCtx.lineWidth = 3.5 * (this.radius / 4); // Tia dày hơn cho sao lớn hơn
        pCtx.globalAlpha = spikeOpacity;

        // --- Tạo Gradient cho tia sáng ---
        // Tia sáng sẽ sáng nhất ở tâm và mờ dần ra 2 đầu
        const gradient = pCtx.createLinearGradient(this.x - spikeLength, 0, this.x + spikeLength, 0);
        const spikeColor = `rgba(255, 255, 255, ${spikeOpacity})`;
        gradient.addColorStop(0, 'transparent');
        gradient.addColorStop(0.5, spikeColor); // Sáng nhất ở giữa
        gradient.addColorStop(1, 'transparent');
        
        pCtx.strokeStyle = gradient;

        // Vẽ tia ngang
        pCtx.beginPath();
        pCtx.moveTo(this.x - spikeLength, this.y);
        pCtx.lineTo(this.x + spikeLength, this.y);
        pCtx.stroke();
        
        // Vẽ tia dọc (phải xoay canvas để dùng lại gradient ngang)
        pCtx.save();
        pCtx.translate(this.x, this.y);
        pCtx.rotate(Math.PI / 2);
        pCtx.translate(-this.x, -this.y);
        pCtx.beginPath();
        pCtx.moveTo(this.x - spikeLength, this.y);
        pCtx.lineTo(this.x + spikeLength, this.y);
        pCtx.stroke();
        pCtx.restore();

        pCtx.globalAlpha = 1; // Reset globalAlpha
    }

    drawPath() {
        if (this.history.length < 2) return;
        pathCtx.strokeStyle = this.color;
        pathCtx.lineWidth = this.radius * TRAIL_BASE_WIDTH_FACTOR;
        pathCtx.lineCap = 'round';
        pathCtx.globalAlpha = TRAIL_BASE_OPACITY;
        pathCtx.beginPath();
        pathCtx.moveTo(this.history[1].x, this.history[1].y);
        pathCtx.lineTo(this.x, this.y);
        pathCtx.stroke();
        pathCtx.globalAlpha = 1.0;
    }

    update() {
        // --- Cập nhật hiệu ứng lấp lánh ---
        this.twinkleFactor += this.twinkleSpeed;
        if (this.twinkleFactor > 1.2 || this.twinkleFactor < 0.7) {
            this.twinkleSpeed *= -1; // Đảo chiều khi đạt giới hạn
        }

        this.history.unshift({ x: this.x, y: this.y });
        if (this.history.length > HISTORY_LENGTH) this.history.pop();
        
        const dx = blackHole.x - this.x;
        const dy = blackHole.y - this.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        if (distance < blackHole.radius || distance > CONTAINMENT_RADIUS * 2.5) {
            this.reset();
            return;
        }
        const force = blackHole.mass / (distance * distance);
        if (distance > 0) {
            this.vx += (dx / distance) * force;
            this.vy += (dy / distance) * force;
        }
        if (distance < CRITICAL_DISTANCE) {
            this.vx *= STRONG_DRAG;
            this.vy *= STRONG_DRAG;
        } else {
            this.vx *= WEAK_DRAG;
            this.vy *= WEAK_DRAG;
        }
        this.x += this.vx;
        this.y += this.vy;
    }
}


    function initParticles() {
         if (particles.length === 0) {
            for (let i = 0; i < PARTICLE_COUNT; i++) { particles.push(new Particle()); }
        } else { particles.forEach(p => p.reset()); }
    }

    function animateGalaxy(time) { // <-- THÊM MỚI: Thêm tham số `time`
        particles.forEach(p => p.update());
        pathCtx.fillStyle = 'rgba(30, 5, 0, 0.1)'; 
        pathCtx.fillRect(0, 0, pathCanvas.width, pathCanvas.height);
        particles.forEach(p => p.drawPath());
        pCtx.clearRect(0, 0, particleCanvas.width, particleCanvas.height);
        particles.forEach(p => p.drawParticle());
        drawSwirl();
        drawCenterGlow(); 
        drawBlackHoleCore();
        drawGlowRing();
        drawOuterGlowRing();
        
        drawGlowCircle2(time); // <-- THÊM MỚI: Gọi hàm vẽ với tham số time
        
        requestAnimationFrame(animateGalaxy); // <-- THAY ĐỔI: Truyền time vào lần gọi tiếp theo
    }
    
    function init() {
        setAllCanvasSize(); 
        initParticles(); 
        animateGalaxy(0); // <-- THAY ĐỔI: Khởi tạo với time = 0
    }
    window.addEventListener('resize', setAllCanvasSize);
    init();
</script>

    <!-- ========================================================== -->
    <!-- == SCRIPT 2: HIỆU ỨNG XOÁY FBM (ĐÃ CẬP NHẬT MÀU) ======== -->
    <!-- ========================================================== -->
    <script>
        (() => {
            const SWIRL_COMPUTE_SIZE = 412;
            const swirlCanvas = document.getElementById('swirlComputeCanvas');
            const ctx = swirlCanvas.getContext('2d');
            const size = SWIRL_COMPUTE_SIZE;
            swirlCanvas.width = size; swirlCanvas.height = size;
            const noiseTextureURL = 'https://static.nodetoy.co/static/texture_library/noise/512/Noise_003.jpg';
            const noiseImage = new Image();
            noiseImage.crossOrigin = 'anonymous';
            let noiseImageData = null;
            let uniforms = {
                _Time: { value: 0.0 },
                _TwirlCenter: { value: { x: 0.5, y: 0.5 } },
                _TwirlStrength: { value: 2.5 },
                _RotationSpeed: { value: 0.07 },
                _AlphaStartRadius: { value: 0.3 },
                _AlphaEndRadius: { value: 0.5 },
                _PinchStrength: { value: 2.0 },
                _NoiseScaleBase: { value: 5.0 },
                _NoiseOctaves: { value: 1 },
                _NoiseLacunarity: { value: 2.0 },
                _NoiseGain: { value: 1 },
                _NoiseBias: { value: 0.0 }
            };
            const targetFPS = 20; const frameInterval = 1000 / targetFPS; let lastFrameTime = 0;
            noiseImage.onload = function() {
                const tempCanvas = document.createElement('canvas'); const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = noiseImage.width; tempCanvas.height = noiseImage.height;
                tempCtx.drawImage(noiseImage, 0, 0);
                noiseImageData = tempCtx.getImageData(0, 0, noiseImage.width, noiseImage.height);
                animate(0);
            };
            noiseImage.onerror = () => { console.error("Lỗi khi tải texture nhiễu."); };
            noiseImage.src = noiseTextureURL;
            function animate(currentTime) {
                requestAnimationFrame(animate);
                if (currentTime - lastFrameTime < frameInterval) return;
                lastFrameTime = currentTime;
                uniforms._Time.value = currentTime / 1000;
                if (noiseImageData) { drawSwirlEffect(); }
            }
            function drawSwirlEffect() {
                 const outputImageData = ctx.createImageData(size, size);
                 const outputData = outputImageData.data;
                 const baseColor = [255, 120, 0];
                 const { value: twirlStrength } = uniforms._TwirlStrength;
                 const { value: rotationSpeed } = uniforms._RotationSpeed;
                 const { value: pinchStrength } = uniforms._PinchStrength;
                 const rotAngle = uniforms._Time.value * rotationSpeed;
                 for (let y = 0; y < size; y++) {
                     for (let x = 0; x < size; x++) {
                         const index = (y * size + x) * 4;
                         let uv_x = x / size, uv_y = y / size;
                         const dx_center = uv_x - 0.5;
                         const dy_center = uv_y - 0.5;
                         const distFromCenter = Math.sqrt(dx_center * dx_center + dy_center * dy_center);
                         let transformedUV = twirl(uv_x, uv_y, 0.5, 0.5, twirlStrength, pinchStrength);
                         let translated_x = transformedUV.x - 0.5; let translated_y = transformedUV.y - 0.5;
                         let rotated_x = translated_x * Math.cos(rotAngle) - translated_y * Math.sin(rotAngle);
                         let rotated_y = translated_x * Math.sin(rotAngle) + translated_y * Math.cos(rotAngle);
                         let final_uv_x = rotated_x + 0.5; let final_uv_y = rotated_y + 0.5;
                         if (final_uv_x < 0 || final_uv_x > 1 || final_uv_y < 0 || final_uv_y > 1) { outputData[index + 3] = 0; continue; }
                         let totalNoise = 0.0, totalAmplitude = 0.0, currentScale = uniforms._NoiseScaleBase.value, currentAmplitude = 1.0;
                         for (let i = 0; i < uniforms._NoiseOctaves.value; i++) {
                            const noiseValue = getWrappedNoiseValue(final_uv_x, final_uv_y, currentScale, noiseImageData);
                            totalNoise += (noiseValue * 2.0 - 1.0) * currentAmplitude;
                            totalAmplitude += currentAmplitude;
                            currentScale *= uniforms._NoiseLacunarity.value; currentAmplitude *= uniforms._NoiseGain.value;
                         }
                         let finalNoiseRatio = 0.0;
                         if (totalAmplitude > 0) {
                             let biasedNoise = (totalNoise / totalAmplitude) + uniforms._NoiseBias.value;
                             finalNoiseRatio = Math.max(0.0, Math.min(1.0, (biasedNoise + 1.0) * 0.5));
                         }
                         let alphaByDistance = 1.0;
                         if (distFromCenter >= uniforms._AlphaEndRadius.value) { alphaByDistance = 0.0; } 
                         else if (distFromCenter > uniforms._AlphaStartRadius.value) { alphaByDistance = 1.0 - (distFromCenter - uniforms._AlphaStartRadius.value) / (uniforms._AlphaEndRadius.value - uniforms._AlphaStartRadius.value); }
                         const finalAlpha = finalNoiseRatio * alphaByDistance;
                         outputData[index] = baseColor[0];
                         outputData[index + 1] = baseColor[1];
                         outputData[index + 2] = baseColor[2];
                         outputData[index + 3] = finalAlpha * 255;
                     }
                 }
                 ctx.putImageData(outputImageData, 0, 0);
            }
            const getWrappedNoiseValue = (u, v, scale, imageData) => {
                let sample_u = (((u * scale) % 1) + 1) % 1, sample_v = (((v * scale) % 1) + 1) % 1;
                const noiseX = Math.floor(sample_u * imageData.width), noiseY = Math.floor(sample_v * imageData.height);
                return imageData.data[(noiseY * imageData.width + noiseX) * 4] / 255.0;
            };
            function twirl(x, y, centerX, centerY, strength, pinchStrength) {
                const dx = x - centerX; const dy = y - centerY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const angle = strength * (1.0 - dist);
                const sinAngle = Math.sin(angle); const cosAngle = Math.cos(angle);
                let twirled_dx = (dx * cosAngle - dy * sinAngle) * (1.0 - pinchStrength * (1.0 - dist));
                let twirled_dy = (dx * sinAngle + dy * cosAngle) * (1.0 - pinchStrength * (1.0 - dist));
                return { x: twirled_dx + centerX, y: twirled_dy + centerY };
            }
        })();
        
    </script>

    <!-- ========================================================== -->
    <!-- == SCRIPT 3: HIỆU ỨNG VÒNG MÂY (ĐÃ CẬP NHẬT MÀU) ========= -->
    <!-- ========================================================== -->
    <script>
        const mainCanvas = document.getElementById('CloudRing');
        const mainCtx = mainCanvas.getContext('2d');
        const cloudVortexEffect = {
            canvas: document.createElement('canvas'), ctx: null, noiseImageData: null, isReady: false,
            size: 412, 
            config: {
                innerRadius: 0.22,
                outerRadius: 0.5,  
                falloff: 0.12,       
                speed: 0.1,
                twirlStrength: 1.0,
                noiseOctaves: 2,
                noiseScaleBase: 1.2,
                noiseLacunarity: 2.0,
                noiseGain: 0.25,
                color: [255, 255, 255],
                opacity: 1
            },
            init() {
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.canvas.width = this.size; this.canvas.height = this.size;
                const noiseImage = new Image(); noiseImage.crossOrigin = 'anonymous';
                noiseImage.onload = () => {
                    const tempCtx = document.createElement('canvas').getContext('2d');
                    tempCtx.canvas.width = noiseImage.width; tempCtx.canvas.height = noiseImage.height;
                    tempCtx.drawImage(noiseImage, 0, 0);
                    this.noiseImageData = tempCtx.getImageData(0, 0, noiseImage.width, noiseImage.height);
                    this.isReady = true;
                };
                noiseImage.src = 'https://static.nodetoy.co/static/texture_library/noise/512/Noise_003.jpg';
            },
            clamp: (v,n,x) => Math.max(n, Math.min(v, x)),
            smoothstep: (e0, e1, x) => { const t = cloudVortexEffect.clamp((x - e0) / (e1 - e0), 0.0, 1.0); return t*t*(3-2*t); },
            getWrappedNoiseValue(u,v,s,d) { let su=(((u*s)%1)+1)%1,sv=(((v*s)%1)+1)%1; return d.data[(Math.floor(sv*d.height)*d.width+Math.floor(su*d.width))*4]/255;},
            fbm(u,v) {let t=0.0, a=1.0, s=this.config.noiseScaleBase;for(let i=0;i<this.config.noiseOctaves;i++){t+=this.getWrappedNoiseValue(u,v,s,this.noiseImageData)*a;s*=this.config.noiseLacunarity;a*=this.config.noiseGain;}return t;},
            update(time) {
                if (!this.isReady) return;
                const outputImageData = this.ctx.createImageData(this.size, this.size);
                const data = outputImageData.data; const cfg = this.config;
                const rotAngle = time * cfg.speed; const cosA = Math.cos(rotAngle); const sinA = Math.sin(rotAngle);
                for (let y = 0; y < this.size; y++) {
                    for (let x = 0; x < this.size; x++) {
                        const i = (y * this.size + x) * 4; const uvx = x/this.size, uvy = y/this.size;
                        const dx = uvx - 0.5, dy = uvy - 0.5;
                        const dist = Math.sqrt(dx*dx+dy*dy);
                        const shapeAlpha = this.smoothstep(cfg.innerRadius,cfg.innerRadius+cfg.falloff,dist)*(1.0-this.smoothstep(cfg.outerRadius-cfg.falloff,cfg.outerRadius,dist));
                        if(shapeAlpha <= 0){ data[i+3] = 0; continue; }
                        const twirlAngle=cfg.twirlStrength*(1.0-this.clamp(dist/cfg.outerRadius,0.0,1.0));
                        const cosT=Math.cos(twirlAngle),sinT=Math.sin(twirlAngle);
                        const tdx=dx*cosT-dy*sinT,tdy=dx*sinT+dy*cosT;
                        const fx=(tdx*cosA-tdy*sinA)+0.5,fy=(tdx*sinA+tdy*cosA)+0.5;
                        const noise = this.fbm(fx, fy);
                        const finalAlpha = shapeAlpha*noise*cfg.opacity;
                        data[i] = cfg.color[0]; data[i+1] = cfg.color[1]; data[i+2] = cfg.color[2];
                        data[i+3] = finalAlpha * 255;
                    }
                }
                this.ctx.putImageData(outputImageData, 0, 0);
            }
        };
        
        function animateCloudRing(currentTime) {
            const timeInSeconds = currentTime / 1000;
            cloudVortexEffect.update(timeInSeconds);
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            if (cloudVortexEffect.isReady) {
                const scaleFactor = 1.5;
                const newWidth = cloudVortexEffect.canvas.width*scaleFactor, newHeight=cloudVortexEffect.canvas.height*scaleFactor;
                const x = (mainCanvas.width - newWidth)/2, y = (mainCanvas.height-newHeight)/2;
                mainCtx.drawImage(cloudVortexEffect.canvas, x, y, newWidth, newHeight);
            }
            requestAnimationFrame(animateCloudRing);
        }

        cloudVortexEffect.init(); animateCloudRing(0);
    </script>
</body>
</html>